### Assembly & Nasm tips

1) We can't move directly byte to 64 register like so:
https://stackoverflow.com/questions/22621340/why-cant-i-move-directly-a-byte-to-a-64-bit-register

mov rax, byte [rbp-0x4]  <- Wrong!

instead of we can use movze instruction which extends high part of register with zeros:

movze rax, byte [rbp-0x4] section .text

the code generated by gcc:
```asm
global _start
_start:
mov    BYTE  [rbp-0x3],0x62
mov    BYTE  [rbp-0x2],0x61
movzx  edx,BYTE  [rbp-0x3]
movzx  eax,BYTE  [rbp-0x2]
add    eax,edx
mov    BYTE  [rbp-0x1],al
mov    eax,0x0
```


2) Try to avoid using partional register(ah, al..) because the working with hole register is much faster
https://stackoverflow.com/questions/41573502/why-doesnt-gcc-use-partial-registers

3) 32-bit registers zero the upper part of the full 64-bit register
https://stackoverflow.com/questions/11177137/why-do-x86-64-instructions-on-32-bit-registers-zero-the-upper-part-of-the-full-6?noredirect=1&lq=1

### struct usage example

```asm
section .bss
struc user ; define struct
    name resb 20
    age resb 4
endstruc

section .data
mystruc:
    istruc user ; init user object
        at name, db "Dima"
        at age, db 20
    iend

section .text
global main
main:
     mov rax,[mystruc+age] ; get access to the struct field.
     ret
```

Read from file and output to stdout (silly example)
```
; nasm -felf64 main.asm && ld main.o && ./a.out
section .data
filename: db "./data.txt", 0

section .bss
buff: resb 64

section .text
global _start

_start:
    ; open file
    mov rax, 2
    mov rdi, filename
    mov rsi, 0
    mov rdx, 0
    syscall

    mov rbx, rax ; fd

    ; read file
    mov rax, 0
    mov rdi, rbx
    mov rsi, buff
    mov rdx, 64 ; how much to read
    syscall

    ; print
    mov       rax, 1
    mov       rdi, 1
    mov       rsi, buff
    mov       rdx, 64
    syscall

    ; close file
    mov rax, 3
    mov rdi, rbx
    syscall

    mov rax, 60             ; system call for exit
    mov rdi, 0              ; exit code 0
    syscall
```
Read from stdin
```
section .bss
buff: resb 64

section .text
global _start

_start:
    ; read from stdin
    mov rax, 0
    mov rdi, 1
    mov rsi, buff
    mov rdx, 64 ; how much to read
    syscall

    ; print
    mov       rax, 1
    mov       rdi, 1
    mov       rsi, buff
    mov       rdx, 64
    syscall

    mov rax, 60             ; system call for exit
    mov rdi, 0              ; exit code 0
    syscall
```
